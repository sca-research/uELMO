!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
CONFIG_H_	Configure.h	2;"	d
CORE_H_	core.h	3;"	d
CORE_STATUS	core.h	/^}CORE_STATUS;$/;"	t	typeref:struct:__anon1
CPSR_C	core.h	8;"	d
CPSR_N	core.h	6;"	d
CPSR_Q	core.h	10;"	d
CPSR_V	core.h	9;"	d
CPSR_Z	core.h	7;"	d
Clock	core.c	/^void Clock(bool pause)$/;"	f
Close_DataFile	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^void Close_DataFile()\/\/SMURF_ADAPTING, change this$/;"	f
Close_Output	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^void Close_Output()\/\/SMURF_ADAPTING, change this$/;"	f
D2E_instrreg	core.h	/^		uint16_t D2E_instrreg;\/\/Pesudo register: in theory should be already tranferred to control signal, here we store the instruction instead$/;"	m	struct:__anon1
D2E_reg1	core.h	/^		unsigned int D2E_reg1;\/\/pipeline register, barrier between Decode and Execute	(i.e. E.1)$/;"	m	struct:__anon1
D2E_reg1_data	core.h	/^		unsigned int D2E_reg1_data;\/\/input data for pipeline register 1, barrier between Decode and Execute	(i.e. D.9)$/;"	m	struct:__anon1
D2E_reg1_valid	core.h	/^		bool D2E_reg1_valid;\/\/update pipeline register 1$/;"	m	struct:__anon1
D2E_reg2	core.h	/^		unsigned int D2E_reg2;\/\/pipeline register, barrier between Decode and Execute	(i.e. E.2)$/;"	m	struct:__anon1
D2E_reg2_data	core.h	/^		unsigned int D2E_reg2_data;\/\/input data for pipeline register 2, barrier between Decode and Execute	(i.e. D.10)$/;"	m	struct:__anon1
D2E_reg2_valid	core.h	/^		bool D2E_reg2_valid;\/\/update pipeline register 2$/;"	m	struct:__anon1
DEBUG_CORE	Configure.h	11;"	d
DEBUG_MEM	Configure.h	10;"	d
DECODE_H_	Decode.h	2;"	d
Decode_OneCycle	Decode.c	/^void Decode_OneCycle(bool prev)$/;"	f
Decode_destination_regindex	core.h	/^		uint8_t Decode_destination_regindex;\/\/Destination register index$/;"	m	struct:__anon1
Decode_instr_disp	core.h	/^		char Decode_instr_disp[50];\/\/Discription for the decode instruction$/;"	m	struct:__anon1
Decode_port_data	core.h	/^		unsigned int Decode_port_data[3];\/\/Current Decoding Read ports data (i.e. D.5-D.7)$/;"	m	struct:__anon1
Decode_port_regindex	core.h	/^		uint8_t  Decode_port_regindex[3];\/\/Current Decoding Read ports index (0-15, often 0-7) (i.e. D.2-D.4)$/;"	m	struct:__anon1
Decode_valid	core.h	/^		bool  Decode_valid;\/\/A flag that stall the pipeline when jump happens$/;"	m	struct:__anon1
EMUIO_H_	EmuIO.h	2;"	d
EMULATOR_H_	Emulator.h	3;"	d
EXECUTE_H_	Execute.h	2;"	d
Execute_ALU_result	core.h	/^		unsigned int Execute_ALU_result;\/\/Current ALU output$/;"	m	struct:__anon1
Execute_Imm	core.h	/^		unsigned int Execute_Imm;\/\/Current Execute Immediate data$/;"	m	struct:__anon1
Execute_OneCylce	/home/salties/Share/git/uELMO/Linux/uelmo/Execute.c	/^bool Execute_OneCylce(bool wait_mem)$/;"	f	signature:(bool wait_mem)
Execute_OneInstr	Emulator.c	/^int Execute_OneInstr(int* cycle)$/;"	f
Execute_destination_regindex	core.h	/^		uint8_t Execute_destination_regindex;\/\/Execute register index: 0-15 valid, 0xff: no output$/;"	m	struct:__anon1
Execute_instr_disp	core.h	/^		char Execute_instr_disp[50];\/\/Discription for the execute instruction$/;"	m	struct:__anon1
Execute_multicycle_regindex	core.h	/^		uint8_t Execute_multicycle_regindex;\/\/Current register index for multi-cycle execution: 0-7 valid$/;"	m	struct:__anon1
Execute_valid	core.h	/^		bool  Execute_valid;\/\/A flag that stall the pipeline when jump happens$/;"	m	struct:__anon1
F2D_instrreg	core.h	/^		uint16_t F2D_instrreg;\/\/pipeline register, barrier between Fetch and Decode (i.e. D.1)	$/;"	m	struct:__anon1
FETCH_H_	Fetch.h	2;"	d
Fetch_OneCycle	Fetch.c	/^void Fetch_OneCycle()$/;"	f
Fetch_instruction_new	core.h	/^		uint16_t Fetch_instruction_new;\/\/Fetched new instruction (i.e. F.3)$/;"	m	struct:__anon1
Fetch_valid	core.h	/^		bool  Fetch_valid;\/\/A flag that stall the pipeline when jump happens$/;"	m	struct:__anon1
MEMORY_H_	Memory.h	2;"	d
Memory_OneCycle	Memory.c	/^bool Memory_OneCycle()$/;"	f
Memory_addr	core.h	/^		unsigned int Memory_addr;\/\/Address bus of the memory: must align to 4$/;"	m	struct:__anon1
Memory_data	core.h	/^		unsigned int Memory_data;\/\/shared (Read and write) data bus: must be 32-bit$/;"	m	struct:__anon1
Memory_instr_disp	core.h	/^		char Memory_instr_disp[50];\/\/Discription for the memory instruction$/;"	m	struct:__anon1
Memory_read_targetreg	core.h	/^		uint8_t Memory_read_targetreg;\/\/For read instruction, the targt regsiter$/;"	m	struct:__anon1
Memory_read_targetreg_buf	core.h	/^		uint8_t Memory_read_targetreg_buf;\/\/For read instruction, the targt regsiter$/;"	m	struct:__anon1
Memory_readbuf	core.h	/^		unsigned int Memory_readbuf;\/\/read buffer on the read bus$/;"	m	struct:__anon1
Memory_writebuf	core.h	/^		unsigned int Memory_writebuf;\/\/write buffer on the write bus$/;"	m	struct:__anon1
Memory_writebuf_delayed	core.h	/^		unsigned int Memory_writebuf_delayed;\/\/write buffer on the write bus$/;"	m	struct:__anon1
N	Configure.h	/^int N;$/;"	v
N_ind	Configure.h	/^int N_ind;$/;"	v
OnTrace	core.c	/^bool OnTrace=false;$/;"	v
Open_DataFile	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^void Open_DataFile(char* filename)\/\/SMURF_ADAPTING, change this$/;"	f	signature:(char* filename)
Open_OutputFile	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^void Open_OutputFile(char* filename)\/\/SMURF_ADAPTING, change this$/;"	f	signature:(char* filename)
RAMADDMASK	Memory.h	5;"	d
RAMSIZE	Memory.h	8;"	d
ROMADDMASK	Memory.h	4;"	d
ROMSIZE	Memory.h	7;"	d
Rand_Byte	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^unsigned int Rand_Byte()$/;"	f
Read_Binary	/home/salties/Share/git/uELMO/Linux/uelmo/uELMO.c	/^void Read_Binary(char* filename)$/;"	f	signature:(char* filename)
Read_Byte	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^unsigned int Read_Byte()$/;"	f
Read_reg_update	core.h	/^		bool Read_reg_update;\/\/if true, update the register according to Memory_read_targetreg and Memory_readbuf$/;"	m	struct:__anon1
Read_type	core.h	/^		uint8_t Read_type;\/\/0 word, 1 byte, 2 half-word$/;"	m	struct:__anon1
Read_valid	core.h	/^		bool Read_valid;\/\/set it true when a new read address is sent to address bus$/;"	m	struct:__anon1
SignExtend_B	Memory.c	/^unsigned int SignExtend_B(unsigned int rc, unsigned int rb)$/;"	f
SignExtend_HB	Memory.c	/^unsigned int SignExtend_HB(unsigned int rc, unsigned int rb)$/;"	f
SignExtend_byte_valid	core.h	/^		bool SignExtend_byte_valid;\/\/sign extend$/;"	m	struct:__anon1
SignExtend_halfbyte_valid	core.h	/^		bool SignExtend_halfbyte_valid;\/\/sign extend$/;"	m	struct:__anon1
UELMO_ERROR	/home/salties/Share/git/uELMO/Linux/uelmo/uelmo.h	3;"	d
UELMO_H	/home/salties/Share/git/uELMO/Linux/uelmo/uelmo.h	2;"	d
Write_EndofTrace	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^void Write_EndofTrace()$/;"	f
Write_Frame	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^void Write_Frame()$/;"	f
Write_type	core.h	/^		uint8_t Write_type;\/\/0 word, 1 byte, 2 half-word$/;"	m	struct:__anon1
Write_valid	core.h	/^		bool Write_valid;\/\/set it true when a new read address is sent to address bus$/;"	m	struct:__anon1
Write_valid_delayed	core.h	/^		bool Write_valid_delayed;\/\/set it true when the previous Write_valid is true$/;"	m	struct:__anon1
bool	Configure.h	7;"	d
check_delay	core.c	/^bool check_delay(unsigned int reg)$/;"	f
core_current	core.c	/^CORE_STATUS core_current;$/;"	v
core_valid	core.h	/^	    bool core_valid;\/\/a flag for reaching the end of this execution$/;"	m	struct:__anon1
cpsr	core.h	/^		unsigned int cpsr;\/\/architectural$/;"	m	struct:__anon1
cpsr_data	core.h	/^		unsigned int cpsr_data;\/\/new data for cpsr$/;"	m	struct:__anon1
cpsr_valid	core.h	/^		bool cpsr_valid;\/\/update cpsr$/;"	m	struct:__anon1
datafp	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^FILE* datafp=NULL;$/;"	v
do_cflag	core.c	/^void do_cflag ( unsigned int a, unsigned int b, unsigned int c )$/;"	f
do_cflag_bit	core.c	/^void do_cflag_bit (unsigned int x )$/;"	f
do_nflag	core.c	/^void do_nflag (unsigned int x )$/;"	f
do_vflag	core.c	/^void do_vflag ( unsigned int a, unsigned int b, unsigned int c )$/;"	f
do_vflag_bit	core.c	/^void do_vflag_bit (unsigned int x )$/;"	f
do_zflag	core.c	/^void do_zflag (unsigned int x )$/;"	f
false	Configure.h	9;"	d
fetch16	Memory.c	/^unsigned int fetch16 ( unsigned int addr )$/;"	f
fetch32	Memory.c	/^unsigned int fetch32 ( unsigned int addr )$/;"	f
fvr	Configure.h	/^bool fvr;$/;"	v
glitchy_Decode_port_data	core.h	/^		unsigned int glitchy_Decode_port_data[3];\/\/Decode the current instruction according to the previous instruction decoding style$/;"	m	struct:__anon1
glitchy_Decode_port_regindex	core.h	/^		unsigned int glitchy_Decode_port_regindex[3];\/\/Decode the current instruction according to the previous instruction decoding style$/;"	m	struct:__anon1
main	/home/salties/Share/git/uELMO/Linux/uelmo/uELMO.c	/^int main ( int argc, char *argv[] )$/;"	f	signature:( int argc, char *argv[] )
outfp	/home/salties/Share/git/uELMO/Linux/uelmo/EmuIO.c	/^FILE* outfp=NULL;$/;"	v
ram	Memory.h	/^unsigned short ram[RAMSIZE>>1];$/;"	v
read16	Memory.c	/^unsigned int read16 ( unsigned int addr )$/;"	f
read32	Memory.c	/^unsigned int read32 ( unsigned int addr )$/;"	f
read8	Memory.c	/^uint8_t read8 ( unsigned int addr )$/;"	f
read_register	core.c	/^unsigned int read_register ( unsigned int reg )$/;"	f
read_register_forward	core.c	/^unsigned int read_register_forward ( unsigned int reg )$/;"	f
reg	core.h	/^		unsigned int reg[16];\/\/architectural$/;"	m	struct:__anon1
reset	Emulator.c	/^int reset ( void )$/;"	f
rom	Memory.h	/^unsigned short rom[ROMSIZE>>1];$/;"	v
run	Emulator.c	/^int run ( void )$/;"	f
true	Configure.h	8;"	d
write16	Memory.c	/^void write16 ( unsigned int addr, unsigned int data )$/;"	f
write32	Memory.c	/^void write32 ( unsigned int addr, unsigned int data )$/;"	f
write_register	core.c	/^void write_register (unsigned int reg, unsigned int data )$/;"	f
